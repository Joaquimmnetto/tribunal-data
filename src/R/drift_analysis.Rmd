---
title: "Topic Change Analysis"
author: "Joaquim Neto"
output:
  html_document: default
  pdf_document: default
---

```{r setup, echo=FALSE, include=TRUE}
	require(ggplot2)
	require(data.table)
	require(igraph)
	require(visNetwork)
	require(arules)
	require(rpart)
	require(rattle)
	setwd("~/PyCharm-Workspace/tribunaldb/")
	#load('ts_data_lda_sym_15.RData')
	
	plot.aggr <- function(dt,title='all'){
	ggplot(dt) + geom_smooth(aes(x=value, y=tactics, color="Tactics"), span=0.8) + 
		geom_smooth(aes(x=value, y=tactics.pos, color="Tactics/Pos"), span=0.8) + 
		geom_smooth(aes(x=value, y=small.talk, color="Small Talk"), span=0.8) + 
		geom_smooth(aes(x=value, y=complaints, color="Complaints"), span=0.8) + 
		geom_smooth(aes(x=value, y=arguments, color="Arguments"), span=0.8) + 
		geom_smooth(aes(x=value, y=insults, color="Insults"), span=0.8) + 
		geom_smooth(aes(x=value, y=taunts, color="Taunts"), span=0.8) +
		ggtitle(title) + coord_cartesian(xlim=c(0, 5))
}
```


#Objetivos:
###1) Descobrir possíveis pontos de virada, aonde o *ofensor* passa de um comportamento normal para um comportamento tóxico
	
* Até agora (com os experimentos usando apriori), não fica evidente que exista tal ponto de virada. Fica evidente que o ofensor se comporta toxicamente desde do começo da partida, apesar desse comportamento intensificar um pouco no decorrer desta.
	
###2) Descobrir os principais tópicos para cada _timeslice_

* Há pouca variação de tópicos no geral entre timeslices, o que não implica que não haja uma troca.

###3) Descobrir quais as principais tendências de troca de tópico

* A prinicipal tendência é dos topícos manterem-se os mesmos, mas estamos escavando as situações de troca para entender como elas ocorrem.
* Apriori não tá me levando muito longe...
* Também pode ser lido como tentar prever ts.x a partir de ts.(x-1)...?
	
(ie. topico a tende a mudar para topico b)

#Parâmetros

####Tamanho de cada timeslice:
600s

####Clusterizador e dados usados: 
LDA, sem divisão de grupos por timeslice, dataset NA completo.

####Peso usado na interpretação
tf(cluster)-idf(corpus) aplicado nas top-100 palavras de cada cluster.

#Preprocessamento
####1) Removido timeslices acima de 60min(engloba ~95% das tslices) 
```{r echo=FALSE}
ggplot(topics) + geom_histogram(aes(x=timeslice),bins=30)
```


#Análise
##Uso dos tópicos através dos timeslices
###Método:

####Todos os grupos
```{r echo=FALSE}
plot.aggr(ts.aggr)
```

####Grupos inimigos
```{r echo=FALSE}
plot.aggr(ts.aggr.enemy, 'enemies')
```

####Grupos aliados
```{r echo=FALSE}
plot.aggr(ts.aggr.ally, 'aliados')
```

####Grupos ofensores
```{r echo=FALSE}
plot.aggr(ts.aggr.offender, 'ofensores')
```

###Divisão em pos/neg

####Todos os Grupos:
```{r echo=FALSE}
ggplot(ts.aggr) + geom_smooth(aes(x=value, y=pos,color='Positive'),span=0.8) + geom_tile(aes(x=value, y=pos, color='Positive')) +
	geom_smooth(aes(x=value, y=neg, color='Negative'),span=0.8) + geom_tile(aes(x=value, y=neg, color='Negative')) +
	coord_cartesian(xlim=c(0, 5))
```

####Grupos Aliados:
```{r echo=FALSE}
ggplot(ts.aggr.ally) + geom_smooth(aes(x=value, y=pos,color='Positive'),span=0.8) + geom_tile(aes(x=value, y=pos, color='Positive')) +
	geom_smooth(aes(x=value, y=neg, color='Negative'),span=0.8) + geom_tile(aes(x=value, y=neg, color='Negative')) +
	coord_cartesian(xlim=c(0, 5))
```

####Grupos Inimigos:
```{r echo=FALSE}
ggplot(ts.aggr.enemy) + geom_smooth(aes(x=value, y=pos,color='Positive'),span=0.8) + geom_tile(aes(x=value, y=pos, color='Positive')) +
	geom_smooth(aes(x=value, y=neg, color='Negative'),span=0.8) + geom_tile(aes(x=value, y=neg, color='Negative')) +
	coord_cartesian(xlim=c(0, 5))
```

####Grupos Ofensores:
```{r echo=FALSE}
ggplot(ts.aggr.offender) + geom_smooth(aes(x=value, y=pos,color='Positive'),span=0.8) + geom_tile(aes(x=value, y=pos, color='Positive')) +
	geom_smooth(aes(x=value, y=neg, color='Negative'),span=0.8) + geom_tile(aes(x=value, y=neg, color='Negative')) +
	coord_cartesian(xlim=c(0, 5))
```

#Experimentos com apriori

##Relação entre tópicos em diferentes timeslices

###Experimento 1:
Apriori com 30% de confiança(correlação fraca), 0.3% de suporte (~10% do menor tópico considerado(other.langs)) e lift minimo de 1.3/0.7, limitado a um par de timeslices consecutivos, somente aonde lhs!=rhs.

####Timeslices 0 e 1:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( ts.topics.col[ts.0!=ts.1, .(ts.0,ts.1)] )
```

```{r echo=FALSE}
	with(results, rules.table[order(rules.table$lhs),])
	results$rules.graph
```

####Timeslices 1 e 2:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( ts.topics.col[ts.1!=ts.2, .(ts.1,ts.2)] )
```

```{r echo=FALSE}
	with(results, rules.table[order(rules.table$lhs),])
	results$rules.graph
```

####Timeslices 2 e 3:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( ts.topics.col[ts.2!=ts.3, .(ts.2,ts.3)] )
```

```{r echo=FALSE}
	with(results, rules.table[order(rules.table$lhs),])
	results$rules.graph
```

####Timeslices 3 e 4:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( ts.topics.col[ts.3!=ts.4, .(ts.3,ts.4)] )
```

```{r echo=FALSE}
	with(results, rules.table[order(rules.table$lhs),])
	results$rules.graph
```

####Timeslices 4 e 5:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( ts.topics.col[ts.4!=ts.5, .(ts.4,ts.5)] )
```

```{r echo=FALSE}
	with(results, rules.table[order(rules.table$lhs),])
	results$rules.graph
```

####Resultados:
Tactics aparenta funcionar como uma espécie de 'meio campo' para os outros tópicos positivos, e complaints.

* Tactics normalmente precede small talk, tactics/pos e complaints
* Esses tópicos normalmente implicam em tactics, o que indica essa relação de 'ida e volta' entre tactics e esses tópicos.

Entretanto, complaints e tactics têm uma relação mais profunda, com tactics constantemente levando a complaints:

* Para as transições ts.0 -> ts.1 e ts.1 -> ts.2

Uma hipótese é que tactics funcione mais como um 'topico neutro' do que um tópico positivo, sendo usado quando não há nenhum tipo de sentimento envolvido na partida(seja ele positivo ou negativo). Contudo, ele ainda pende mais para o lado positivo, não relacionando-se com a maioria dos tópicos negativos, como arguments, insults e taunts.

Arguments aparecem uma vez (timeslices 2 e 3), sendo precedidos por complaints(ts.3=arguments -> ts.2=complaints). isso pode mostrar uma toxicidade levemente maior nestes tslices, como confirmado pelos gráficos de concentração de tópicos positivos x negativos, mas ainda é uma evidência muito fraca para concluirmos algo a mais disso.

##Ponto de mudança de comportamento dos ofensores:

###Experimento 1:
Apriori com 30% de confiança(correlação fraca), 0.3% de suporte (~10% do menor tópico considerado(other.langs)) e lift minimo de 1.3/0.7, limitado a um par de timeslices consecutivos, somente aonde lhs!=rhs, para tópicos utilizados pelos ofensores.

Consideraremos como esse ponto de mudança, quando o ofensor mudar seu tópico usado de positivo para negativo.

####Timeslices 0 e 1:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.0!=ts.1 & relation.offender=='offender', .(ts.0,ts.1)] )
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```

####Timeslices 1 e 2:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.1!=ts.2 & relation.offender=='offender', .(ts.1,ts.2)])
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```

####Timeslices 2 e 3:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.2!=ts.3 & relation.offender=='offender', .(ts.2,ts.3)])
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```

####Timeslices 3 e 4:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.3!=ts.4 & relation.offender=='offender', .(ts.3,ts.4)])
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```

####Timeslices 4 e 5:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.4!=ts.5 & relation.offender=='offender', .(ts.4,ts.5)])
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```

####Resultados:
Tactics mantêm seu papel como meio campo, contudo agora ele somente varia com complaints. Entretanto, Tactics/Pos -> Tactics, aparece em timeslices mais tardios (2 e 3, 3 e 4, 4 e 5). Podemos considerar isso como uma queda na positividade destes ofensores nestes timeslices, já que não há nenhuma 'entrada' em tactics/pos, somente 'saidas'.

Quanto aos tópicos negativos, Complaints são uma presença constante, sempre trocando-se com tactics, como dito anteriormente. Arguments aparecem mais depois do inicio da partida (timeslices >= (1 e 2)), sempre com uma relação de precedência com complaints, o que, **se considerarmos complaints como um tópico menos tóxico do que arguments** pode ser considerado como uma evolução gradual na toxicidade. 

Entretanto, nem insults nem taunts aparecem nas regras obtidas. Um motivo possível para isso pode ser a sua baixa frequência geral (ou minha falta de entendimento pleno do apriori -.-), ou simplesmente o fato destes tópicos terem uma aparição mais errática e não necessariamente relacionada com o desenvolvimento da partida e do stress causado por ela, mas sim alguma condição externa.

Sobre um 'turning point' para o comportamento do ofensor, não fica realmente evidente que exista um. Fica claro que o ofensor se comporta toxicamente desde do começo da partida, apesar desse comportamente intensificar um pouco no decorrer desta. Isso fica mostrado tanto nas transições feitas acima, aonde o ofensor já começa com complaints/tacitcs, podendo este tópico alternar-se com tactics/complaints ou arguments no decorrer da partida, mas nada que indique a transição de um comportamento não-tóxico para um comportamento tóxico. Isso também é demonstrado no plot de timeslices x topic usage dos ofensores, com o uso de tópicos negativos mantendo-se relativamente constantes, mas com um pequeno pico na timeslice 1 (10-20 min de partida).

##Ponto de mudança de comportamento dos nao-ofensores:

###Experimento 1:
Apriori com 30% de confiança(correlação fraca), 0.3% de suporte (~10% do menor tópico considerado(other.langs)) e lift minimo de 1.3/0.7, limitado a um par de timeslices consecutivos, somente aonde lhs!=rhs, para tópicos utilizados pelos ofensores.

Consideraremos como esse ponto de mudança, quando o jogador mudar seu tópico usado de positivo para negativo. Objetivo deste experimento é comparar estes resultados com o comportamento de ofensores, e verificar as diferenças.

####Timeslices 0 e 1:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.0!=ts.1 & relation.offender!='offender', .(ts.0,ts.1)] )
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```

####Timeslices 1 e 2:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.1!=ts.2 & relation.offender!='offender', .(ts.1,ts.2)])
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```

####Timeslices 2 e 3:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.2!=ts.3 & relation.offender!='offender', .(ts.2,ts.3)])
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```

####Timeslices 3 e 4:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.3!=ts.4 & relation.offender!='offender', .(ts.3,ts.4)])
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```

####Timeslices 4 e 5:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.4!=ts.5 & relation.offender!='offender', .(ts.4,ts.5)])
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```

####Results:
Resultados bastante similares aos adquiridos na análise de regras de todos os tópicos, com breve exceção que 'arguments' não aparece novamente aqui. Nenhuma nova conclusão significativa a se tirar disso.

##Ponto de mudança de comportamento dos aliados:

###Experimento 1:
Apriori com 30% de confiança(correlação fraca), 0.3% de suporte (~10% do menor tópico considerado(other.langs)) e lift minimo de 1.3/0.7, limitado a um par de timeslices consecutivos, somente aonde lhs!=rhs, para tópicos utilizados pelos ofensores.

Consideraremos como esse ponto de mudança, quando o jogador mudar seu tópico usado de positivo para negativo. Objetivo deste experimento é comparar estes resultados com o comportamento de outros grupos, e verificar as diferenças.

####Timeslices 0 e 1:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.0!=ts.1 & relation.offender=='ally', .(ts.0,ts.1)] )
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```

####Timeslices 1 e 2:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.1!=ts.2 & relation.offender=='ally', .(ts.1,ts.2)])
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```

####Timeslices 2 e 3:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.2!=ts.3 & relation.offender=='ally', .(ts.2,ts.3)])
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```

####Timeslices 3 e 4:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.3!=ts.4 & relation.offender=='ally', .(ts.3,ts.4)])
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```

####Timeslices 4 e 5:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.4!=ts.5 & relation.offender=='ally', .(ts.4,ts.5)])
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```

####Results:
Resultados também similares aos do com o dataset completo. Aqui os arguments aparecem de maneira um pouco menos timida (arguments precedem complaints em 1->2 e 2->3), e tactics não é continuado por small talk no inicio da partida (0->1), mas small talk ainda pode 'virar' tactics no mesmo intervalo. 

##Ponto de mudança de comportamento dos inimigos:

###Experimento 1:
Apriori com 30% de confiança(correlação fraca), 0.3% de suporte (~10% do menor tópico considerado(other.langs)) e lift minimo de 1.3/0.7, limitado a um par de timeslices consecutivos, somente aonde lhs!=rhs, para tópicos utilizados pelos ofensores.

Consideraremos como esse ponto de mudança, quando o jogador mudar seu tópico usado de positivo para negativo. Objetivo deste experimento é comparar estes resultados com o comportamento de outros grupos, e verificar as diferenças.

####Timeslices 0 e 1:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.0!=ts.1 & relation.offender=='enemy', .(ts.0,ts.1)] )
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```

####Timeslices 1 e 2:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.1!=ts.2 & relation.offender=='enemy', .(ts.1,ts.2)])
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```

####Timeslices 2 e 3:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.2!=ts.3 & relation.offender=='enemy', .(ts.2,ts.3)])
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```

####Timeslices 3 e 4:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.3!=ts.4 & relation.offender=='enemy', .(ts.3,ts.4)])
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```

####Timeslices 4 e 5:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(ts.topics.col[ts.4!=ts.5 & relation.offender=='enemy', .(ts.4,ts.5)])
```

```{r echo=FALSE}
	if(!is.null(results))
		with(results, rules.table[order(rules.table$lhs),])
	if(!is.null(results))
		results$rules.graph
```
o
####Resultados
Tópicos envolvidos continuam os mesmos, com Tactics exercendo o mesmo papel de sempre, mas aqui nós vemos uma relação muito mais próxima entre Tactics e small talk, com small talk -> tactics e tactics precendendo small talk sendo bem mais constantes. A relação entre complaints e tactics também é mais fraca nestes grupos, com complaints -> tactics e sendo precedido por este, mas sem tactics -> complaints.

##Evolução dos topicos com o tempo

###Experimento:
Apriori com 0% de confiança(todas as regras), 0.3% de suporte (~10% do menor tópico considerado(other.langs)) e lift minimo de 1.3/0.7, limitado a um par de timeslices consecutivos. Resultados filtrados para mostrar somentes as regras lhs->rhs.

Objetivo aqui é usar as regras para demonstrar os caminhos possíveis entre os tópicos e as probabilidades destes caminhos ocorrerem. Transições que eventualmente não aparecerem são consideradas insignificantes demais(muito pouco suporte), ou são ao acaso (lift muito próximo de 1)

###Full:

####Timeslices 0 e 1:
```{r, fig.show='hide', include=FALSE}
min.conf = 0
min.lift = 0.2
dt.base = ts.topics.col
	results = slices.arules( dt.base[ts.0!="other" & ts.1!="other", .(ts.0,ts.1)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Timeslices 1 e 2:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( dt.base[ts.1!="other" & ts.2!="other", .(ts.1,ts.2)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Timeslices 2 e 3:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( dt.base[ts.2!="other" & ts.3!="other", .(ts.2,ts.3)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Timeslices 3 e 4:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( dt.base[ts.3!="other" & ts.4!="other", .(ts.3,ts.4)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Timeslices 4 e 5:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( dt.base[ts.4!="other" & ts.5!="other", .(ts.4, ts.5)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Tudo junto
```{r, fig.show='hide', include=FALSE}
	min.conf = 0
min.lift = 0.2
results = slices.arules(list(y1=dt.base[ts.0!="other" & ts.1!="other", .(ts.0,ts.1)],
														 y2=dt.base[ts.1!="other" & ts.2!="other", .(ts.1,ts.2)],
														 y3=dt.base[ts.2!="other" & ts.3!="other", .(ts.2,ts.3)],
														 y4=dt.base[ts.3!="other" & ts.4!="other", .(ts.3,ts.4)],
														 y5=dt.base[ts.4!="other" & ts.5!="other", .(ts.4,ts.5)]
														),
												 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)

```

```{r echo=FALSE}
	inspectDT(results$rules)
	results$rules.graph %>% 
	visPhysics(barnesHut=list(springLength=500)) %>%
	visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 600)
```

####Resultados
Praticamente todas as transições apresentam lift positivo somente em transações aonde o topico não muda (ie. topico -> topico). Contudo, muitos desses topicos participam de transações aonde o lift é negativo com outros topicos. No geral, topicos positivos tem lift negativo com alguns topicos negativos, e topicos negativos tem lift negativo com alguns topicos positivos. Other langs. tem lift negativo com topicos positivos. Essas relações variam um pouco em algumas transições de timeslice mas têm essa regra geral.

###Aliados:

####Timeslices 0 e 1:
```{r, fig.show='hide', include=FALSE}
min.conf = 0
min.lift = 0.2
dt.base = ts.topics.col[relation.offender=='ally']
	results = slices.arules( dt.base[ts.0!="other" & ts.1!="other", .(ts.0,ts.1)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Timeslices 1 e 2:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( dt.base[ts.1!="other" & ts.2!="other", .(ts.1,ts.2)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Timeslices 2 e 3:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( dt.base[ts.2!="other" & ts.3!="other", .(ts.2,ts.3)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Timeslices 3 e 4:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( dt.base[ts.3!="other" & ts.4!="other", .(ts.3,ts.4)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Timeslices 4 e 5:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( dt.base[ts.4!="other" & ts.5!="other", .(ts.4, ts.5)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Tudo junto


```{r, fig.show='hide', include=FALSE}
	min.conf = 0
min.lift = 0.2
results = slices.arules(list(y1=dt.base[ts.0!="other" & ts.1!="other", .(ts.0,ts.1)],
														 y2=dt.base[ts.1!="other" & ts.2!="other", .(ts.1,ts.2)],
														 y3=dt.base[ts.2!="other" & ts.3!="other", .(ts.2,ts.3)],
														 y4=dt.base[ts.3!="other" & ts.4!="other", .(ts.3,ts.4)],
														 y5=dt.base[ts.4!="other" & ts.5!="other", .(ts.4,ts.5)]
														),
												 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)

```

```{r echo=FALSE}
	inspectDT(results$rules)
	results$rules.graph %>% 
	visPhysics(barnesHut=list(springLength=500)) %>%
	visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 600)
```

####Resultados

###Enemies:

####Timeslices 0 e 1:
```{r, fig.show='hide', include=FALSE}
min.conf = 0
min.lift = 0.2
dt.base = ts.topics.col[relation.offender=='enemy']
	results = slices.arules( dt.base[ts.0!="other" & ts.1!="other", .(ts.0,ts.1)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Timeslices 1 e 2:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( dt.base[ts.1!="other" & ts.2!="other", .(ts.1,ts.2)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Timeslices 2 e 3:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( dt.base[ts.2!="other" & ts.3!="other", .(ts.2,ts.3)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Timeslices 3 e 4:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( dt.base[ts.3!="other" & ts.4!="other", .(ts.3,ts.4)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Timeslices 4 e 5:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( dt.base[ts.4!="other" & ts.5!="other", .(ts.4, ts.5)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Tudo junto
```{r, fig.show='hide', include=FALSE}
	min.conf = 0
min.lift = 0.2
results = slices.arules(list(y1=dt.base[ts.0!="other" & ts.1!="other", .(ts.0,ts.1)],
														 y2=dt.base[ts.1!="other" & ts.2!="other", .(ts.1,ts.2)],
														 y3=dt.base[ts.2!="other" & ts.3!="other", .(ts.2,ts.3)],
														 y4=dt.base[ts.3!="other" & ts.4!="other", .(ts.3,ts.4)],
														 y5=dt.base[ts.4!="other" & ts.5!="other", .(ts.4,ts.5)]
														),
												 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)

```

```{r echo=FALSE}
	inspectDT(results$rules)
	results$rules.graph %>% 
	visPhysics(barnesHut=list(springLength=500)) %>%
	visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 600)
```

####Resultados


###Ofensores:

####Timeslices 0 e 1:
```{r, fig.show='hide', include=FALSE}
min.conf = 0
min.lift = 0.2
dt.base = ts.topics.col[relation.offender=='offender']
	results = slices.arules( dt.base[ts.0!="other" & ts.1!="other", .(ts.0,ts.1)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	 inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Timeslices 1 e 2:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( dt.base[ts.1!="other" & ts.2!="other", .(ts.1,ts.2)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	 inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Timeslices 2 e 3:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( dt.base[ts.2!="other" & ts.3!="other", .(ts.2,ts.3)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Timeslices 3 e 4:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( dt.base[ts.3!="other" & ts.4!="other", .(ts.3,ts.4)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	  inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Timeslices 4 e 5:
```{r, fig.show='hide', include=FALSE}
	results = slices.arules( dt.base[ts.4!="other" & ts.5!="other", .(ts.4, ts.5)] , 
													 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)
```

```{r echo=FALSE}
	  inspectDT(results$rules)
	# results$rules.graph %>% visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 400)
```

####Tudo junto
```{r, fig.show='hide', include=FALSE}
	min.conf = 0
min.lift = 0.2
results = slices.arules(list(y1=dt.base[ts.0!="other" & ts.1!="other", .(ts.0,ts.1)],
														 y2=dt.base[ts.1!="other" & ts.2!="other", .(ts.1,ts.2)],
														 y3=dt.base[ts.2!="other" & ts.3!="other", .(ts.2,ts.3)],
														 y4=dt.base[ts.3!="other" & ts.4!="other", .(ts.3,ts.4)],
														 y5=dt.base[ts.4!="other" & ts.5!="other", .(ts.4,ts.5)]
														),
												 min.confidence = min.conf, lhs.only="", min.lift.dist = min.lift)

```

```{r echo=FALSE}
	inspectDT(results$rules)
	results$rules.graph %>% 
	visPhysics(barnesHut=list(springLength=500)) %>%
	visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 600)
```

####Resultados

#Transições sem consideração de tempo
Dataset construido com todas as transições ocorridas, sem consideração das timeslices das transações. Apriori com 0% de confiança(todas as regras), 0.3% de suporte (~10% do menor tópico considerado(other.langs)) e lift minimo de 1.3/0.7, limitado a um par de timeslices consecutivos. Resultados filtrados para mostrar somentes as regras lhs->rhs.

##Transações com repetição

###Full
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(verticalize(ts.topics.col), 
											min.confidence = 0.003,
											lhs.only = "")
```

```{r echo=FALSE}
	inspectDT(results$rules)
	results$rules.graph# %>% 
	#visPhysics(barnesHut=list(springLength=500)) %>%
	#visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 600)
```
####Results:
Complaints e arguments agora funcionam como meio campo entre os tópicos. Esses dois tópicos são conectados entre si, e conectam topicos positivos com negativos. Contudo, há uma ponte direta entre esses tópicos, na figura de tactics/positive -> insults. Usar o dataset junto não parece ser a solução mais ideal para a análise. Nos próximos passos os grupos serão analizados individualmente, e depois na forma de ofensores e não ofensores.
###Aliados
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(verticalize(ts.topics.col[relation.offender=='ally']), 
											min.confidence = 0.000
											,lhs.only=""
											)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	results$rules.graph #%>% 
	#visPhysics(barnesHut=list(springLength=500)) %>%
	#visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 600)
```

###Inimigos
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(verticalize(ts.topics.col[relation.offender=='enemy']), 
											min.confidence = 0.000
											,lhs.only=""
											)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	results$rules.graph #%>% 
	#visPhysics(barnesHut=list(springLength=500)) %>%
	#visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 600)
```

###Ofensores
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(verticalize(ts.topics.col[relation.offender=='offender']), 
											min.confidence = 0.000
											,lhs.only=""
											)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	results$rules.graph#	%>% 
	#visPhysics(barnesHut=list(springLength=500)) %>%
	#visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 600)
```

###Não-Ofensores
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(verticalize(ts.topics.col[relation.offender!='offender']), 
											min.confidence = 0.000
											,lhs.only=""
											)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	results$rules.graph#	%>% 
	#visPhysics(barnesHut=list(springLength=500)) %>%
	#visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 600)
```

###Conclusão
Em todos os três casos, arguments e complaints executam o papel do meio-campo entre topicos mais positivos e topicos mais negativos. Contudo, a relação entre tactics/positive e insults persiste, fornecendo uma quebra significativa nesse padrão, e dentro de cada região, há pouca interconexão entre os tópicos presentes. Nos casos de full/enemy e ally, tactics/positive não é alcançado por ninguém, e é alcançado por tactics, no caso do offender. A conexão entre taunts e insults é não existente, e a conexão entre small talk e tactics é feita via complaints/arguments. 

Essa análise foi feita sem considerar valoes de confiança, considerando somente lifts de 1.3 ou superior.

##Transações sem repetição

Somente considerada nas regras as transações sem repetições (x->x)

###Full
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(verticalize(ts.topics.col)[lhs!=rhs], 
											min.confidence = 0.003
											,lhs.only=""
											)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	results$rules.graph #%>% 
	#visPhysics(barnesHut=list(springLength=200)) %>%
	#visHierarchicalLayout(direction = "LR", sortMethod="directed")
```

####Results:

Neste caso, Tactics serve como um interlocutor entre os tópicos positivos e complaints. Complaints serve como uma porta de entrada para arguments, interlocutando com o mesmo. Aqui podemos considerar que tactics faz o papel de meio campo sozinho, enquanto complaints serve de entrada para negativos, e tactics também serve como topico de entrada para os positivos, além do seu papel de 'meio campo'.
Insults relacionam-se somente com other.langs, topico esse que também se relaciona com tactics/pos. Como other.langs é um tópico bem particular as circunstâncias de uma partida(pessoas que não falam inglês no time), o significado semântico disso não é muito claro.

###Aliados
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(verticalize(ts.topics.col[relation.offender=='ally'])[lhs!=rhs], 
											min.confidence = 0.00
											,lhs.only=""
											)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	results$rules.graph #%>% 
	#visPhysics(barnesHut=list(springLength=500)) %>%
	#visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 600)
```
####Results
Tactics mantêm a mesma função anterior, mediando tópicos positivos e complaints. Contudo a relação de complaints com arguments muda, transformando-se em uma relação de mão única complaints -> arguments. Tactics/positive possui uma relação direta com insults, novamente(tp -> insults).

###Inimigos
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(verticalize(ts.topics.col[relation.offender=='enemy'])[lhs!=rhs], 
											min.confidence = 0.000, 
											lhs.only="")
```

```{r echo=FALSE}
	inspectDT(results$rules)
	results$rules.graph #%>% 
	#visPhysics(barnesHut=list(springLength=500)) %>%
	#visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 600)
```

####Results:
Complaints e arguments tem um caso parecido com allies, com uma ligação de caminho único. Contudo arguments tem uma ligação dupla com taunts. Insults só liga-se com other.langs, e tactics.pos agora possui uma ligação com small.talk, e nenhuma com other langs ou insults.

###Ofensores
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(verticalize(ts.topics.col[relation.offender=='offender'])[lhs!=rhs], 
											min.confidence = 0.000, 
											lhs.only="")
```

```{r echo=FALSE}
	inspectDT(results$rules)
	results$rules.graph# %>% 
	#visPhysics(barnesHut=list(springLength=500)) %>%
	#visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 600)
```

####Conclusion
Aqui as relações ficam mais confusas, com tactics complaints, arguments e tactics/positive realizando ligações entre topicos positivos e negativos. As relações entre tp e tactics mantêm-se, contudo, small talk tem uma relação unidirecional com tactics (sm -> tactics) e com arguments(arguments -> sm). taunts agora leva a complaints, além de tactics, mas continua 'isolado' sem receber de ninguém. A ligação entre tactics/positive e insults reaparece aqui, de maneira unidirecional (tp->insults).

###Não-Ofensores
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(verticalize(ts.topics.col[relation.offender!='offender'])[lhs!=rhs], 
											min.confidence = 0.000, 
											lhs.only="")
```

```{r echo=FALSE}
	inspectDT(results$rules)
	results$rules.graph# %>% 
	#visPhysics(barnesHut=list(springLength=500)) %>%
	#visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 600)
```

###Conclusões
Existe uma 'área central' de transições, entretanto seus limites não são completamente claros. Em não ofensores, essa área é ocupada por tactics e complaints, com tactics realizando a interloucução entre tópicos mais positivos(small talk e tactics/positive) e complaints. Já complaints liga-se a arguments, que também 'recebe' de taunts, tornando complaints uma 'porta de entrada' para tópicos negativos. O comportamento de taunts e especialmente de insults não fica claro nestas análises, provavelmente devido a sua baixa frequência. Uma análise mais detalhada destes vai ser tentada a seguir.

##Insults, com autoreferência
Partidas aonde insults aparecem ao menos uma vez. conf.=0 e min.lift=1.3

###Full
```{r, fig.show='hide', include=FALSE}
	dt = ts.topics.col[ ts.0 == 'insults' | ts.1 == 'insults' | ts.2 == 'insults' | 
											ts.3 == 'insults' | ts.4 == 'insults' | ts.5 == 'insults']
	results = slices.arules(verticalize(dt), 
											min.confidence = 0.000
											#,lhs.only=""
											)
```

```{r echo=FALSE}
	inspectDT(results$rules)
	results$rules.graph# %>% 
	#visPhysics(barnesHut=list(springLength=500)) %>%
	#visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 600)
```

###Ofensores
###Não-Ofensores
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(verticalize(ts.topics.col[relation.offender!='offender'])[lhs!=rhs], 
											min.confidence = 0.000, 
											lhs.only="")
```

```{r echo=FALSE}
	inspectDT(results$rules)
	results$rules.graph# %>% 
	#visPhysics(barnesHut=list(springLength=500)) %>%
	#visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 600)
```

###Não-Ofensores
###Não-Ofensores
```{r, fig.show='hide', include=FALSE}
	results = slices.arules(verticalize(ts.topics.col[relation.offender!='offender'])[lhs!=rhs], 
											min.confidence = 0.000, 
											lhs.only="")
```

```{r echo=FALSE}
	inspectDT(results$rules)
	results$rules.graph# %>% 
	#visPhysics(barnesHut=list(springLength=500)) %>%
	#visHierarchicalLayout(direction = "LR", sortMethod="directed", levelSeparation = 600)
```


#As Arvres somos nozes

Foram criadas árvores de decisão, usando como treinamento os tópicos e as métricas de performance e contamianação de cada partida.

### Total:

####Timeslices 0 e 1:
```{r echo=FALSE}
	#fancyRpartPlot(fit01.full)
```

####Timeslices 1 e 2:
```{r echo=FALSE}
	#fancyRpartPlot(fit12.full)
```

####Timeslices 2 e 3:
```{r echo=FALSE}
	#fancyRpartPlot(fit23.full)
```

####Timeslices 3 e 4:
```{r echo=FALSE}
	#fancyRpartPlot(fit34.full)
```

####Timeslices 4 e 5:
```{r echo=FALSE}
	#fancyRpartPlot(fit45.full)
```

####Results
Resultados dos testes com árvores são mais confusos, mas ainda, em maioria (contudo não tão esmagadora quando as das arules) indicam que topico->topico. Contudo, o resultado mais relevante daqui é que *contaminação e performance não aparecem em nenhuma das transições* ou seja, aparentemente estas métricas não tem influência sobre a transição dos tópicos. Estas tendências continuam mesmo quando as árvores são construidas baseadas em grupos específicos. Foram construídas arvores com aliados, inimigos, ofensores, inimigos contaminados e não contaminados.

Também é importamente relatar que nenhuma dessas regras estão filtradas por lift, o que pode gerar regras que aparecem por simplesmente causa da distribuição dos dados.


# Limitações dessaporra

* Tamanho do vocabulário variado entre timeslices.
    * Um grupo pode falar muito em uma timeslice e pouco em outras.
    * Isso pode ser amenizado criando algum tipo de peso para a importância de cada timeslice baseado no tamanho do texto dela.
        * ISSO É UM SACO DE PROGRAMAR AAAAAA.
        
* Timeslices simplesmente muito grandes
    * 10 min pode ser um muito grande para capturar as nuances, diminuir o tamanho da janela
        * RIP memória.
    * Pode se normalizar a partida e fazer uma divisão similar ao trabalho do Kwak et al.
        * Não me cheira bem tbh, os momentos de uma partida de lol só não funcionam desse jeito.
 
        
# TODO:

* Fazer regras com árvores, usando como parâmetros: relation.offender,performance,contamination,topic.
    * Melhores chances de encontrar regras mais complexas que seriam mais complicadas de se encontrar usando arules.
    * Ou eu posso fazer essa birosca com arules mesmo, mas teria que discretizar performance.

TODO: comparar timeslices iguais de grupos diferentes, para verificar se há relação entre o diálogo usado por um time e o usado por outro, também comparar com performance e contaminação para verificar se há relações significativas(ie. aumento na contaminação == mais transições negativas, etc).